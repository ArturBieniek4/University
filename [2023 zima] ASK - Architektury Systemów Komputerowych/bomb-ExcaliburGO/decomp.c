#include <stdlib.h>
#include <stdint.h>

int64_t sub_1020()
{
    int64_t var_8 = data_5008;
    /* jump -> data_5010 */
}

char* getenv(char const* name)
{
    /* tailcall */
    return getenv(name);
}

int64_t sub_1036()
{
    int64_t var_8 = 0;
    /* tailcall */
    return sub_1020();
}

int32_t* __errno_location()
{
    /* tailcall */
    return __errno_location();
}

int64_t sub_1046()
{
    int64_t var_8 = 1;
    /* tailcall */
    return sub_1020();
}

char* strcpy(char* arg1, char const* arg2)
{
    /* tailcall */
    return strcpy(arg1, arg2);
}

int64_t sub_1056()
{
    int64_t var_8 = 2;
    /* tailcall */
    return sub_1020();
}

int32_t puts(char const* str)
{
    /* tailcall */
    return puts(str);
}

int64_t sub_1066()
{
    int64_t var_8 = 3;
    /* tailcall */
    return sub_1020();
}

ssize_t write(int32_t fd, void const* buf, uint64_t nbytes)
{
    /* tailcall */
    return write(fd, buf, nbytes);
}

int64_t sub_1076()
{
    int64_t var_8 = 4;
    /* tailcall */
    return sub_1020();
}

uint64_t strlen(char const* arg1)
{
    /* tailcall */
    return strlen(arg1);
}

int64_t sub_1086()
{
    int64_t var_8 = 5;
    /* tailcall */
    return sub_1020();
}

int32_t printf(char const* format, ...)
{
    /* tailcall */
    return printf();
}

int64_t sub_1096()
{
    int64_t var_8 = 6;
    /* tailcall */
    return sub_1020();
}

int32_t snprintf(char* s, uint64_t maxlen, char const* format, ...)
{
    /* tailcall */
    return snprintf();
}

int64_t sub_10a6()
{
    int64_t var_8 = 7;
    /* tailcall */
    return sub_1020();
}

int64_t alarm()
{
    /* tailcall */
    return alarm();
}

int64_t sub_10b6()
{
    int64_t var_8 = 8;
    /* tailcall */
    return sub_1020();
}

int32_t close(int32_t fd)
{
    /* tailcall */
    return close(fd);
}

int64_t sub_10c6()
{
    int64_t var_8 = 9;
    /* tailcall */
    return sub_1020();
}

ssize_t read(int32_t fd, void* buf, uint64_t nbytes)
{
    /* tailcall */
    return read(fd, buf, nbytes);
}

int64_t sub_10d6()
{
    int64_t var_8 = 0xa;
    /* tailcall */
    return sub_1020();
}

char* fgets(char* buf, int32_t n, FILE* fp)
{
    /* tailcall */
    return fgets(buf, n, fp);
}

int64_t sub_10e6()
{
    int64_t var_8 = 0xb;
    /* tailcall */
    return sub_1020();
}

__sighandler_t signal(int32_t sig, __sighandler_t handler)
{
    /* tailcall */
    return signal(sig, handler);
}

int64_t sub_10f6()
{
    int64_t var_8 = 0xc;
    /* tailcall */
    return sub_1020();
}

struct hostent* gethostbyname(char const* name)
{
    /* tailcall */
    return gethostbyname(name);
}

int64_t sub_1106()
{
    int64_t var_8 = 0xd;
    /* tailcall */
    return sub_1020();
}

int32_t fprintf(FILE* stream, char const* format, ...)
{
    /* tailcall */
    return fprintf();
}

int64_t sub_1116()
{
    int64_t var_8 = 0xe;
    /* tailcall */
    return sub_1020();
}

int64_t strtol(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtol(nptr, endptr, base);
}

int64_t sub_1126()
{
    int64_t var_8 = 0xf;
    /* tailcall */
    return sub_1020();
}

int32_t fflush(FILE* fp)
{
    /* tailcall */
    return fflush(fp);
}

int64_t sub_1136()
{
    int64_t var_8 = 0x10;
    /* tailcall */
    return sub_1020();
}

int32_t __isoc99_sscanf(char const* s, char const* format, ...)
{
    /* tailcall */
    return __isoc99_sscanf();
}

int64_t sub_1146()
{
    int64_t var_8 = 0x11;
    /* tailcall */
    return sub_1020();
}

int64_t memmove(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memmove(arg1, arg2, arg3);
}

int64_t sub_1156()
{
    int64_t var_8 = 0x12;
    /* tailcall */
    return sub_1020();
}

FILE* fopen(char const* filename, char const* mode)
{
    /* tailcall */
    return fopen(filename, mode);
}

int64_t sub_1166()
{
    int64_t var_8 = 0x13;
    /* tailcall */
    return sub_1020();
}

int32_t sprintf(char* s, char const* format, ...)
{
    /* tailcall */
    return sprintf();
}

int64_t sub_1176()
{
    int64_t var_8 = 0x14;
    /* tailcall */
    return sub_1020();
}

void exit(int32_t status) __noreturn
{
    /* tailcall */
    return exit(status);
}

int64_t sub_1186()
{
    int64_t var_8 = 0x15;
    /* tailcall */
    return sub_1020();
}

int32_t connect(int32_t fd, union __CONST_SOCKADDR_ARG addr, socklen_t len)
{
    /* tailcall */
    return connect(fd, addr, len);
}

int64_t sub_1196()
{
    int64_t var_8 = 0x16;
    /* tailcall */
    return sub_1020();
}

uint32_t sleep(uint32_t seconds)
{
    /* tailcall */
    return sleep(seconds);
}

int64_t sub_11a6()
{
    int64_t var_8 = 0x17;
    /* tailcall */
    return sub_1020();
}

uint16_t** __ctype_b_loc()
{
    /* tailcall */
    return __ctype_b_loc();
}

int64_t sub_11b6()
{
    int64_t var_8 = 0x18;
    /* tailcall */
    return sub_1020();
}

int64_t socket()
{
    /* tailcall */
    return socket();
}

int64_t sub_11c6()
{
    int64_t var_8 = 0x19;
    /* tailcall */
    return sub_1020();
}

void __cxa_finalize(void* d)
{
    /* tailcall */
    return __cxa_finalize(d);
}

void deregister_tm_clones()
{
    return;
}

void register_tm_clones()
{
    return;
}

void __do_global_dtors_aux()
{
    if (completed.0 != 0)
    {
        return;
    }
    if (__cxa_finalize != 0)
    {
        __cxa_finalize(__dso_handle);
    }
    deregister_tm_clones();
    completed.0 = 1;
}

void frame_dummy()
{
    /* tailcall */
    return register_tm_clones();
}

int32_t main(int argc, char** argv)
{
    if (argc == 1)
    {
        infile = stdin;
    }
    else
    {
        if (argc != 2)
        {
            printf("Usage: %s [<input_file>]\n", *argv);
            exit(8);
            /* no return */
        }
        FILE* rax_1 = fopen(argv[1], &data_3004);
        infile = rax_1;
        if (rax_1 == 0)
        {
            printf("%s: Error: Couldn't open %s\n", *argv, argv[1]);
            exit(8);
            /* no return */
        }
    }
    initialize_bomb();
    puts("Welcome to my fiendish little bo…");
    puts("which to blow yourself up. Have …");
    read_line();
    phase_1();
    phase_defused();
    puts("Phase 1 defused. How about the n…");
    read_line();
    phase_2();
    phase_defused();
    puts("That's number 2.  Keep going!");
    read_line();
    phase_3();
    phase_defused();
    puts("Halfway there!");
    read_line();
    phase_4();
    phase_defused();
    puts("So you got that one.  Try this o…");
    read_line();
    phase_5();
    phase_defused();
    puts("Good work!  On to the next...");
    read_line();
    phase_6();
    phase_defused();
    return 0;
}

int64_t phase_1()
{
    char* rdi;
    int32_t rax = strings_not_equal(rdi, "Crikey! I have lost my mojo!");
    if (rax != 0)
    {
        explode_bomb();
        /* no return */
    }
    return rax;
}

int64_t phase_2()
{
    int32_t var_38;
    char* rdi;
    read_six_numbers(rdi, &var_38);
    if (var_38 != 1)
    {
        explode_bomb();
        /* no return */
    }
    int32_t* i = &var_38;
    void var_24;
    int32_t rax_2;
    do
    {
        rax_2 = (*i * 2);
        if (i[1] != rax_2)
        {
            explode_bomb();
            /* no return */
        }
        i = &i[1];
    } while (i != &var_24);
    return rax_2;
}

void phase_3()
{
    char var_11;
    int32_t var_10;
    int32_t var_c;
    char* s;
    if (__isoc99_sscanf(s, "%d %c %d", &var_c, &var_11, &var_10) <= 2)
    {
        explode_bomb();
        /* no return */
    }
    if (var_c > 7) // pierwsza licza <=7
    {
        explode_bomb();
        /* no return */
    }
    char rax_5;
    // char 75 to u
    // var_c -> 0
    // var_11 -> u (0x75)
    // var_10 -> 117 (0x75)
    switch (var_c)
    {
        case 0:
        {
            rax_5 = 0x75;
            if (var_10 != 0x138)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 1:
        {
            rax_5 = 0x6c;
            if (var_10 != 0x15d)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 2:
        {
            rax_5 = 0x69;
            if (var_10 != 0x8a)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 3:
        {
            rax_5 = 0x76;
            if (var_10 != 0x327)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 4:
        {
            rax_5 = 0x6c;
            if (var_10 != 0x2d5)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 5:
        {
            rax_5 = 0x75;
            if (var_10 != 0x305)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 6:
        {
            rax_5 = 0x6f;
            if (var_10 != 0xc7)
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
        case 7:
        {
            rax_5 = 0x75;
            if (var_10 != 0x2b9)  {  // {"86-64.so.2"}}
            {
                explode_bomb();
                /* no return */
            }
            break;
        }
    }
    if (var_11 != rax_5)
    {
        explode_bomb();
        /* no return */
    }
}

uint64_t func4(int32_t arg1, int32_t arg2, int32_t arg3)
{
    int32_t diff = (arg3 - arg2);
    int32_t rbx_4 = ((((diff >> 0x1f) + diff) >> 1) + arg2);
    if (rbx_4 > arg1)
    {
        rbx_4 = (rbx_4 + func4());
    }
    else if (rbx_4 < arg1)
    {
        rbx_4 = (rbx_4 + func4(arg1, (rbx_4 + 1)));
    }
    return rbx_4;
}

int64_t phase_4()
{
    int32_t var_10;
    int32_t var_c;
    char* s;
    if ((__isoc99_sscanf(s, "%d %d", &var_c, &var_10) == 2 && var_c <= 0xe))
    {
        // 7 7
        int32_t rax_2 = func4(var_c, 0, 0xe);
        if ((rax_2 == 7 && var_10 == 7))
        {
            return rax_2;
        }
        explode_bomb();
        /* no return */
    }
    explode_bomb();
    /* no return */
}

int64_t phase_5()
{
    int32_t var_10;
    int32_t i_1;
    char* s;
    if (__isoc99_sscanf(s, "%d %d", &i_1, &var_10) <= 1)
    {
        explode_bomb();
        /* no return */
    }
    int32_t i = (i_1 & 0xf); // pierwsza cyfra 0-15 tylko ma znaczenie
    i_1 = i;
    if (i != 0xf) // 15 nie może być
    {
        int32_t rcx_1 = 0;
        int32_t rdx_1 = 0;
        do
        {
            rdx_1 = (rdx_1 + 1);
            i = *(&array.0 + (i << 2));
            rcx_1 = (rcx_1 + i);
        } while (i != 0xf);
        i_1 = 0xf;
        if ((rdx_1 == 0xf && var_10 == rcx_1))
        {
            return i;
        }
    }
    explode_bomb();
    /* no return */
}

int64_t phase_6()
{
    void var_48;
    void* r13 = &var_48;
    char* rdi;
    read_six_numbers(rdi, &var_48);
    int64_t r14 = 1;
    while (true)
    {
        if ((*r13 - 1) > 5)
        {
            explode_bomb();
            /* no return */
        }
        if (r14 > 5)
        {
            break;
        }
        int64_t rbx_1 = r14;
        do
        {
            if (*r13 == *(&var_48 + (rbx_1 << 2)))
            {
                explode_bomb();
                /* no return */
            }
            rbx_1 = (rbx_1 + 1);
        } while (rbx_1 <= 5);
        r14 = (r14 + 1);
        r13 = (r13 + 4);
    }
    int64_t i = 0;
    int32_t* var_78;
    do
    {
        int32_t rcx_1 = *(&var_48 + (i << 2));
        int32_t rax_4 = 1;
        void* rdx_1 = &node1;
        if (rcx_1 > 1)
        {
            do
            {
                rdx_1 = *(rdx_1 + 8);
                rax_4 = (rax_4 + 1);
            } while (rax_4 != rcx_1);
        }
        &var_78[i] = rdx_1;
        i = (i + 1);
    } while (i != 6);
    int32_t* rbx_2 = var_78;
    void* var_70;
    *(rbx_2 + 8) = var_70;
    void* var_68;
    *(var_70 + 8) = var_68;
    void* var_60;
    *(var_68 + 8) = var_60;
    void* var_58;
    *(var_60 + 8) = var_58;
    void* var_50;
    *(var_58 + 8) = var_50;
    *(var_50 + 8) = 0;
    int32_t i_2 = 5;
    int32_t rax_9;
    int32_t i_1;
    do
    {
        rax_9 = **(rbx_2 + 8);
        if (*rbx_2 < rax_9)
        {
            explode_bomb();
            /* no return */
        }
        rbx_2 = *(rbx_2 + 8);
        i_1 = i_2;
        i_2 = (i_2 - 1);
    } while (i_1 != 1);
    return rax_9;
}

uint64_t fun7(int32_t* arg1, int32_t arg2)
{
    if (arg1 == 0)
    {
        return 0xffffffff;
    }
    int32_t rdx = *arg1;
    uint64_t rax;
    if (rdx > arg2)
    {
        rax = (fun7(*(arg1 + 8)) * 2);
    }
    else
    {
        rax = 0;
        if (rdx != arg2)
        {
            rax = ((fun7(*(arg1 + 0x10)) * 2) + 1);
        }
    }
    return rax;
}

int64_t secret_phase()
{
    int32_t rax_1 = strtol(read_line(), nullptr, 0xa);
    if ((rax_1 - 1) > 0x3e8)
    {
        explode_bomb();
        /* no return */
    }
    if (fun7(&n1, rax_1) != 1)
    {
        explode_bomb();
        /* no return */
    }
    puts("Wow! You've defused the secret s…");
    return phase_defused();
}

void sig_handler() __noreturn
{
    puts("So you think you can stop the bo…");
    sleep(3);
    printf("Well...");
    fflush(stdout);
    sleep(1);
    puts("OK. :-)");
    exit(0x10);
    /* no return */
}

void invalid_phase(int64_t arg1) __noreturn
{
    printf("Invalid phase%s\n", arg1);
    exit(8);
    /* no return */
}

int64_t string_length(char* arg1)
{
    if (*arg1 == 0)
    {
        return 0;
    }
    int32_t rax = 0;
    do
    {
        arg1 = &arg1[1];
        rax = (rax + 1);
    } while (*arg1 != 0);
    return rax;
}

int64_t strings_not_equal(char* arg1, char* arg2)
{
    int64_t rax_2 = 1;
    if (string_length(arg1) == string_length(arg2))
    {
        char rdx_1 = *arg1;
        if (rdx_1 == 0)
        {
            rax_2 = 0;
        }
        else
        {
            int64_t rax_3 = 0;
            while (true)
            {
                if (arg2[rax_3] != rdx_1)
                {
                    rax_2 = 1;
                    break;
                }
                rax_3 = (rax_3 + 1);
                rdx_1 = arg1[rax_3];
                if (rdx_1 == 0)
                {
                    rax_2 = 0;
                    break;
                }
            }
        }
    }
    return rax_2;
}

__sighandler_t initialize_bomb()
{
    return signal(2, sig_handler);
}

int64_t initialize_bomb_solve() __pure
{
    return;
}

int64_t blank_line(char* arg1)
{
    char* rbp = arg1;
    int64_t rax_3;
    while (true)
    {
        char rbx_1 = *rbp;
        if (rbx_1 == 0)
        {
            rax_3 = 1;
            break;
        }
        rbp = &rbp[1];
        if ((*(&*__ctype_b_loc()[rbx_1] + 1) & 0x20) == 0)
        {
            rax_3 = 0;
            break;
        }
    }
    return rax_3;
}

char* skip()
{
    char* rax_2;
    int32_t i;
    do
    {
        rax_2 = fgets(((num_input_strings * 0x50) + &input_strings), 0x50, infile);
        if (rax_2 == 0)
        {
            break;
        }
        i = blank_line(rax_2);
    } while (i != 0);
    return rax_2;
}

void explode_bomb() __noreturn
{
    puts("\nBOOM!!!");
    puts("The bomb has blown up.");
    exit(8);
    /* no return */
}

int32_t read_six_numbers(char* arg1, int64_t arg2)
{
    int32_t rax_3 = __isoc99_sscanf(arg1, "%d %d %d %d %d %d", arg2, (arg2 + 4), (arg2 + 8), (arg2 + 0xc), (arg2 + 0x10), (arg2 + 0x14));
    if (rax_3 <= 5)
    {
        explode_bomb();
        /* no return */
    }
    return rax_3;
}

void* read_line()
{
    if (skip() == 0)
    {
        if (infile == stdin)
        {
            puts("Error: Premature EOF on stdin");
            exit(8);
            /* no return */
        }
        if (getenv("GRADE_BOMB") != 0)
        {
            exit(0);
            /* no return */
        }
        infile = stdin;
        if (skip() == 0)
        {
            puts("Error: Premature EOF on stdin");
            exit(0);
            /* no return */
        }
    }
    uint32_t num_input_strings_2 = num_input_strings;
    int64_t num_input_strings_3 = num_input_strings_2;
    int32_t rax_2 = strlen(((num_input_strings_3 * 0x50) + &input_strings));
    if (rax_2 > 0x4e)
    {
        puts("Error: Input line too long");
        uint32_t num_input_strings_1 = num_input_strings;
        num_input_strings = (num_input_strings_1 + 1);
        int64_t rax_10 = (num_input_strings_1 * 0x50);
        *(&input_strings + rax_10) = 0x636e7572742a2a2a;
        *(rax_10 + 0x5408) = 0x2a2a2a64657461;
        explode_bomb();
        /* no return */
    }
    (&input_strings + (num_input_strings_2 * 0x50))[(rax_2 - 1)] = 0;
    num_input_strings = (num_input_strings_2 + 1);
    return ((num_input_strings_3 * 0x50) + &input_strings);
}

void phase_defused()
{
    if (num_input_strings != 6)
    {
        return;
    }
    void var_60;
    void var_5c;
    void var_58;
    if ((__isoc99_sscanf(&data_54f0, "%d %d %s", &var_5c, &var_60, &var_58) == 3 && strings_not_equal(&var_58, "DrEvil") == 0))
    {
        puts("Curses, you've found the secret …");
        puts("But finding it and solving it ar…");
        secret_phase();
    }
    puts("Congratulations! You've defused …");
}

void sigalrm_handler() __noreturn
{
    fprintf(stderr, "Program timed out after %d secon…", 0);
    exit(1);
    /* no return */
}

int64_t rio_readlineb(int32_t* arg1, void* arg2, int64_t arg3)
{
    void* r12 = arg2;
    int64_t rax_6;
    int32_t r13;
    if (arg3 <= 1)
    {
        r13 = 1;
    label_1d04:
        *r12 = 0;
        rax_6 = r13;
    }
    else
    {
        r13 = 1;
        int32_t rax_2;
        int32_t rax_5;
        int32_t rdx;
        while (true)
        {
            rdx = arg1[1];
            if (rdx <= 0)
            {
                int32_t* rax_1;
                do
                {
                    rax_2 = read(*arg1, &arg1[4], &data_2000);
                    rdx = rax_2;
                    arg1[1] = rax_2;
                    if (rax_2 >= 0)
                    {
                        break;
                    }
                    rax_1 = __errno_location();
                } while (*rax_1 == 4);
                if (rax_2 < 0)
                {
                    rax_5 = -1;
                    break;
                }
                if (rax_2 == 0)
                {
                    rax_5 = 0;
                    break;
                }
                *(arg1 + 8) = &arg1[4];
            }
            char* rax_3 = *(arg1 + 8);
            char rcx_1 = *rax_3;
            *(arg1 + 8) = &rax_3[1];
            arg1[1] = (rdx - 1);
            r12 = (r12 + 1);
            *(r12 - 1) = rcx_1;
            if (rcx_1 == 0xa)
            {
                break;
            }
            r13 = (r13 + 1);
            if (r12 == ((arg2 + arg3) - 1))
            {
                r12 = ((arg2 + arg3) - 1);
                break;
            }
        }
        if (!((rdx <= 0 && rax_2 < 0)))
        {
            goto label_1d04;
        }
        if (rax_5 != 0)
        {
            rax_6 = -1;
        }
        else
        {
            rax_6 = 0;
            if (r13 != 1)
            {
                goto label_1d04;
            }
        }
    }
    return rax_6;
}

uint64_t submitr(char* arg1, int16_t arg2, char* arg3, char* arg4, int64_t arg5, char* arg6, char* arg7, char* arg8)
{
    char* i = arg7;
    int32_t var_805c = 0;
    int32_t fd = socket(2, 1, 0);
    uint64_t rax_12;
    if (fd < 0)
    {
        __builtin_strcpy(arg8, "Error: Client unable to create socket");
        rax_12 = 0xffffffff;
    }
    else
    {
        struct hostent* rax = gethostbyname(arg1);
        if (rax == 0)
        {
            __builtin_strncpy(arg8, "Error: DNS is unable to resolve server address", 0x2f);
            close(fd);
            rax_12 = 0xffffffff;
        }
        else
        {
            int64_t addr = 0;
            int64_t var_40_1 = 0;
            addr = 2;
            memmove(&*addr[4], *rax->h_addr_list, rax->h_length);
            *addr[2] = (ROLW(arg2, 8));
            if (connect(fd, &addr, 0x10) < 0)
            {
                __builtin_strncpy(arg8, "Error: Unable to connect to the server", 0x27);
                close(fd);
                rax_12 = 0xffffffff;
            }
            else
            {
                uint64_t rax_3 = strlen(i);
                if (((((strlen(arg3) + strlen(arg4)) + 0x80) + strlen(arg6)) + (rax_3 * 3)) > &data_2000)
                {
                    __builtin_strcpy(arg8, "Error: Result string too large. Increase SUBMITR_MAXBUF");
                    close(fd);
                    rax_12 = 0xffffffff;
                }
                else
                {
                    void s_1;
                    __builtin_memset(&s_1, 0, &data_2000);
                    int32_t rax_10 = strlen(i);
                    if (rax_10 != 0)
                    {
                        void* rbp_2 = &s_1;
                        do
                        {
                            uint32_t rcx = *i;
                            uint64_t rax_13 = (rcx - 0x2a);
                            if (((rax_13 <= 0x35 && (TEST_BITQ(0x2000000000ffd9, rax_13))) || ((rax_13 > 0x35 || (rax_13 <= 0x35 && !((TEST_BITQ(0x2000000000ffd9, rax_13))))) && ((rcx & 0xdf) - 0x41) <= 0x19)))
                            {
                                *rbp_2 = rcx;
                                rbp_2 = (rbp_2 + 1);
                            }
                            if (((rax_13 > 0x35 || (rax_13 <= 0x35 && !((TEST_BITQ(0x2000000000ffd9, rax_13))))) && ((rcx & 0xdf) - 0x41) > 0x19))
                            {
                                if (rcx == 0x20)
                                {
                                    *rbp_2 = 0x2b;
                                    rbp_2 = (rbp_2 + 1);
                                }
                                else
                                {
                                    if (((rcx - 0x20) > 0x5f && rcx != 9))
                                    {
                                        __builtin_strncpy(arg8, "Error: Result string contains an illegal or unprintable character.", 0x43);
                                        close(fd);
                                        rax_12 = 0xffffffff;
                                        goto label_21db;
                                    }
                                    char s;
                                    snprintf(&s, 8, "%%%02X", rcx);
                                    *rbp_2 = s;
                                    char var_a06f;
                                    *(rbp_2 + 1) = var_a06f;
                                    char var_a06e;
                                    *(rbp_2 + 2) = var_a06e;
                                    rbp_2 = (rbp_2 + 3);
                                }
                            }
                            i = &i[1];
                        } while (i != &i[((rax_10 - 1) + 1)]);
                    }
                    void s_2;
                    snprintf(&s_2, &data_2000, "GET /%s/submitr.pl/?userid=%s&us…", arg3, arg4, arg5, arg6, &s_1, arg3, arg4, arg6, arg5);
                    uint64_t nbytes_1 = strlen(&s_2);
                    uint64_t nbytes = nbytes_1;
                    void* buf = &s_2;
                    ssize_t rax_22;
                    int32_t* rax_23;
                    if (nbytes_1 != 0)
                    {
                        uint64_t nbytes_2;
                        do
                        {
                            rax_22 = write(fd, buf, nbytes);
                            if (rax_22 <= 0)
                            {
                                rax_23 = __errno_location();
                                if (*rax_23 != 4)
                                {
                                    break;
                                }
                                rax_22 = 0;
                            }
                            buf = (buf + rax_22);
                            nbytes_2 = nbytes;
                            nbytes = (nbytes - rax_22);
                        } while (nbytes_2 != rax_22);
                    }
                    if ((nbytes_1 == 0 || (nbytes_1 != 0 && !((rax_22 <= 0 && *rax_23 != 4)))))
                    {
                        int32_t fd_1 = fd;
                        int32_t var_2054_1 = 0;
                        void var_2048;
                        void* var_2050_1 = &var_2048;
                        if (rio_readlineb(&fd_1, &s_2, &data_2000) <= 0)
                        {
                            __builtin_strcpy(arg8, "Error: Client unable to read first header from server");
                            close(fd);
                            rax_12 = 0xffffffff;
                        }
                        else
                        {
                            void var_a068;
                            void var_8058;
                            __isoc99_sscanf(&s_2, "%s %d %[a-zA-z ]", &var_8058, &var_805c, &var_a068);
                            int32_t rdx_5 = var_805c;
                            bool c_3 = rdx_5 < 0xc8;
                            bool z_2 = rdx_5 == 0xc8;
                            if (!(z_2))
                            {
                                sprintf(arg8, "Error: HTTP request failed with …", rdx_5, &var_a068);
                                close(fd);
                                rax_12 = 0xffffffff;
                            }
                            else
                            {
                                while (true)
                                {
                                    void* rsi_7 = &s_2;
                                    int64_t i_1 = 3;
                                    void* const rdi_27 = &data_3466;
                                    while (i_1 != 0)
                                    {
                                        char temp1_1 = *rsi_7;
                                        char temp2_1 = *rdi_27;
                                        c_3 = temp1_1 < temp2_1;
                                        z_2 = temp1_1 == temp2_1;
                                        rsi_7 = (rsi_7 + 1);
                                        rdi_27 = (rdi_27 + 1);
                                        i_1 = (i_1 - 1);
                                        if (!(z_2))
                                        {
                                            break;
                                        }
                                    }
                                    int64_t rax_31;
                                    rax_31 = (!(z_2) && !(c_3));
                                    rax_31 = (rax_31 - 0);
                                    if (rax_31 == 0)
                                    {
                                        int64_t rax_25 = rio_readlineb(&fd_1, &s_2, &data_2000);
                                        bool c_2 = false;
                                        bool z_1 = (rax_25 & rax_25) == 0;
                                        if ((z_1 || (rax_25 & rax_25) < 0 != false))
                                        {
                                            __builtin_strcpy(arg8, "Error: Client unable to read status message from server");
                                            close(fd);
                                            rax_12 = 0xffffffff;
                                        }
                                        else
                                        {
                                            strcpy(arg8, &s_2);
                                            close(fd);
                                            int64_t i_2 = 3;
                                            void* const rdi_19 = &data_3469;
                                            char* rsi_5 = arg8;
                                            while (i_2 != 0)
                                            {
                                                char temp3_1 = *rsi_5;
                                                char temp4_1 = *rdi_19;
                                                c_2 = temp3_1 < temp4_1;
                                                z_1 = temp3_1 == temp4_1;
                                                rsi_5 = &rsi_5[1];
                                                rdi_19 = (rdi_19 + 1);
                                                i_2 = (i_2 - 1);
                                                if (!(z_1))
                                                {
                                                    break;
                                                }
                                            }
                                            rax_12 = -(((!(z_1) && !(c_2)) - 0) != 0);
                                        }
                                        break;
                                    }
                                    rax_31 = rio_readlineb(&fd_1, &s_2, &data_2000);
                                    c_3 = false;
                                    z_2 = (rax_31 & rax_31) == 0;
                                    if (!((!(z_2) && (rax_31 & rax_31) < 0 == false)))
                                    {
                                        __builtin_strncpy(arg8, "Error: Client unable to read headers from server", 0x31);
                                        close(fd);
                                        rax_12 = 0xffffffff;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (((nbytes_1 != 0 && rax_22 <= 0) && *rax_23 != 4))
                    {
                        __builtin_strcpy(arg8, "Error: Client unable to write to the server");
                        close(fd);
                        rax_12 = 0xffffffff;
                    }
                }
            }
        }
    }
label_21db:
    return rax_12;
}

void init_timeout(int32_t arg1)
{
    if (arg1 == 0)
    {
        return;
    }
    signal(0xe, sigalrm_handler);
    uint64_t rdi = 0;
    if (arg1 >= 0)
    {
        rdi = arg1;
    }
    alarm(rdi);
}

int64_t init_driver(int16_t* arg1)
{
    signal(0xd, &__elf_header.ident.signature[1]);
    signal(0x1d, &__elf_header.ident.signature[1]);
    signal(0x1d, &__elf_header.ident.signature[1]);
    int32_t fd = socket(2, 1, 0);
    int64_t rax_3;
    if (fd < 0)
    {
        __builtin_strcpy(arg1, "Error: Client unable to create socket");
        rax_3 = 0xffffffff;
    }
    else
    {
        struct hostent* rax = gethostbyname("changeme.ii.uni.wroc.pl");
        if (rax == 0)
        {
            __builtin_strncpy(arg1, "Error: DNS is unable to resolve server address", 0x2f);
            close(fd);
            rax_3 = 0xffffffff;
        }
        else
        {
            int64_t addr = 0;
            int64_t var_20_1 = 0;
            addr = 2;
            memmove(&*addr[4], *rax->h_addr_list, rax->h_length);
            *addr[2] = 0x6e3b;
            if (connect(fd, &addr, 0x10) < 0)
            {
                sprintf(arg1, "Error: Unable to connect to serv…", "changeme.ii.uni.wroc.pl");
                close(fd);
                rax_3 = 0xffffffff;
            }
            else
            {
                close(fd);
                *arg1 = 0x4b4f;
                arg1[1] = 0;
                rax_3 = 0;
            }
        }
    }
    return rax_3;
}

uint64_t driver_post(char* arg1, int64_t arg2, char* arg3, int32_t arg4, char* arg5)
{
    int16_t* rbx = arg5;
    uint64_t rax;
    if (arg4 != 0)
    {
        printf("\nAUTORESULT_STRING=%s\n", arg3);
        *rbx = 0x4b4f;
        rbx[1] = 0;
        rax = 0;
    }
    else
    {
        if ((arg1 == 0 || (arg1 != 0 && *arg1 == 0)))
        {
            *rbx = 0x4b4f;
            rbx[1] = 0;
            rax = arg4;
        }
        if ((arg1 != 0 && *arg1 != 0))
        {
            rax = submitr("changeme.ii.uni.wroc.pl", 0x3b6e, "csapp", arg1, arg2, "bomblab", arg3, arg5);
        }
    }
    return rax;
}

void __libc_csu_fini() __pure
{
    return;
}

int64_t _fini() __pure
{
    return;
}


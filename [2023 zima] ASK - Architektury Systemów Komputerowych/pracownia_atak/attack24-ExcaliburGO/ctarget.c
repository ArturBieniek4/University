void _init()
{
    if (__gmon_start__ != 0)
    {
        __gmon_start__();
    }
}

int64_t sub_401020()
{
    int64_t var_8 = data_405008;
    /* jump -> data_405010 */
}

int32_t strcasecmp(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strcasecmp(arg1, arg2);
}

int64_t sub_401036()
{
    int64_t var_8 = 0;
    /* tailcall */
    return sub_401020();
}

int32_t* __errno_location()
{
    /* tailcall */
    return __errno_location();
}

int64_t sub_401046()
{
    int64_t var_8 = 1;
    /* tailcall */
    return sub_401020();
}

void srandom(uint32_t x)
{
    /* tailcall */
    return srandom(x);
}

int64_t sub_401056()
{
    int64_t var_8 = 2;
    /* tailcall */
    return sub_401020();
}

int32_t strncmp(char const* arg1, char const* arg2, uint64_t arg3)
{
    /* tailcall */
    return strncmp(arg1, arg2, arg3);
}

int64_t sub_401066()
{
    int64_t var_8 = 3;
    /* tailcall */
    return sub_401020();
}

char* strcpy(char* arg1, char const* arg2)
{
    /* tailcall */
    return strcpy(arg1, arg2);
}

int64_t sub_401076()
{
    int64_t var_8 = 4;
    /* tailcall */
    return sub_401020();
}

int32_t puts(char const* str)
{
    /* tailcall */
    return puts(str);
}

int64_t sub_401086()
{
    int64_t var_8 = 5;
    /* tailcall */
    return sub_401020();
}

ssize_t write(int32_t fd, void const* buf, uint64_t nbytes)
{
    /* tailcall */
    return write(fd, buf, nbytes);
}

int64_t sub_401096()
{
    int64_t var_8 = 6;
    /* tailcall */
    return sub_401020();
}

uint64_t strlen(char const* arg1)
{
    /* tailcall */
    return strlen(arg1);
}

int64_t sub_4010a6()
{
    int64_t var_8 = 7;
    /* tailcall */
    return sub_401020();
}

int64_t mmap(void* addr, uint64_t len, int32_t prot, int32_t flags, int32_t fd, off64_t offset)
{
    /* tailcall */
    return mmap(addr, len, prot, flags, fd, offset);
}

int64_t sub_4010b6()
{
    int64_t var_8 = 8;
    /* tailcall */
    return sub_401020();
}

int32_t printf(char const* format, ...)
{
    /* tailcall */
    return printf();
}

int64_t sub_4010c6()
{
    int64_t var_8 = 9;
    /* tailcall */
    return sub_401020();
}

int64_t memset(void* arg1, int32_t arg2, uint64_t arg3)
{
    /* tailcall */
    return memset(arg1, arg2, arg3);
}

int64_t sub_4010d6()
{
    int64_t var_8 = 0xa;
    /* tailcall */
    return sub_401020();
}

int64_t alarm()
{
    /* tailcall */
    return alarm();
}

int64_t sub_4010e6()
{
    int64_t var_8 = 0xb;
    /* tailcall */
    return sub_401020();
}

int32_t close(int32_t fd)
{
    /* tailcall */
    return close(fd);
}

int64_t sub_4010f6()
{
    int64_t var_8 = 0xc;
    /* tailcall */
    return sub_401020();
}

ssize_t read(int32_t fd, void* buf, uint64_t nbytes)
{
    /* tailcall */
    return read(fd, buf, nbytes);
}

int64_t sub_401106()
{
    int64_t var_8 = 0xd;
    /* tailcall */
    return sub_401020();
}

__sighandler_t signal(int32_t sig, __sighandler_t handler)
{
    /* tailcall */
    return signal(sig, handler);
}

int64_t sub_401116()
{
    int64_t var_8 = 0xe;
    /* tailcall */
    return sub_401020();
}

struct hostent* gethostbyname(char const* name)
{
    /* tailcall */
    return gethostbyname(name);
}

int64_t sub_401126()
{
    int64_t var_8 = 0xf;
    /* tailcall */
    return sub_401020();
}

int32_t fprintf(FILE* stream, char const* format, ...)
{
    /* tailcall */
    return fprintf();
}

int64_t sub_401136()
{
    int64_t var_8 = 0x10;
    /* tailcall */
    return sub_401020();
}

int64_t strtol(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtol(nptr, endptr, base);
}

int64_t sub_401146()
{
    int64_t var_8 = 0x11;
    /* tailcall */
    return sub_401020();
}

int64_t memcpy(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memcpy(arg1, arg2, arg3);
}

int64_t sub_401156()
{
    int64_t var_8 = 0x12;
    /* tailcall */
    return sub_401020();
}

time_t time(time_t* arg1)
{
    /* tailcall */
    return time(arg1);
}

int64_t sub_401166()
{
    int64_t var_8 = 0x13;
    /* tailcall */
    return sub_401020();
}

int64_t random()
{
    /* tailcall */
    return random();
}

int64_t sub_401176()
{
    int64_t var_8 = 0x14;
    /* tailcall */
    return sub_401020();
}

int32_t __isoc99_sscanf(char const* s, char const* format, ...)
{
    /* tailcall */
    return __isoc99_sscanf();
}

int64_t sub_401186()
{
    int64_t var_8 = 0x15;
    /* tailcall */
    return sub_401020();
}

int64_t munmap()
{
    /* tailcall */
    return munmap();
}

int64_t sub_401196()
{
    int64_t var_8 = 0x16;
    /* tailcall */
    return sub_401020();
}

int64_t memmove(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memmove(arg1, arg2, arg3);
}

int64_t sub_4011a6()
{
    int64_t var_8 = 0x17;
    /* tailcall */
    return sub_401020();
}

FILE* fopen(char const* filename, char const* mode)
{
    /* tailcall */
    return fopen(filename, mode);
}

int64_t sub_4011b6()
{
    int64_t var_8 = 0x18;
    /* tailcall */
    return sub_401020();
}

int32_t getopt(int32_t argc, char* const* argv, char const* optstring)
{
    /* tailcall */
    return getopt(argc, argv, optstring);
}

int64_t sub_4011c6()
{
    int64_t var_8 = 0x19;
    /* tailcall */
    return sub_401020();
}

uint64_t strtoul(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtoul(nptr, endptr, base);
}

int64_t sub_4011d6()
{
    int64_t var_8 = 0x1a;
    /* tailcall */
    return sub_401020();
}

int32_t gethostname(char* name, uint64_t len)
{
    /* tailcall */
    return gethostname(name, len);
}

int64_t sub_4011e6()
{
    int64_t var_8 = 0x1b;
    /* tailcall */
    return sub_401020();
}

int32_t sprintf(char* s, char const* format, ...)
{
    /* tailcall */
    return sprintf();
}

int64_t sub_4011f6()
{
    int64_t var_8 = 0x1c;
    /* tailcall */
    return sub_401020();
}

void exit(int32_t status) __noreturn
{
    /* tailcall */
    return exit(status);
}

int64_t sub_401206()
{
    int64_t var_8 = 0x1d;
    /* tailcall */
    return sub_401020();
}

int32_t connect(int32_t fd, union __CONST_SOCKADDR_ARG addr, socklen_t len)
{
    /* tailcall */
    return connect(fd, addr, len);
}

int64_t sub_401216()
{
    int64_t var_8 = 0x1e;
    /* tailcall */
    return sub_401020();
}

int32_t getc(FILE* fp)
{
    /* tailcall */
    return getc(fp);
}

int64_t sub_401226()
{
    int64_t var_8 = 0x1f;
    /* tailcall */
    return sub_401020();
}

int64_t socket()
{
    /* tailcall */
    return socket();
}

int64_t sub_401236()
{
    int64_t var_8 = 0x20;
    /* tailcall */
    return sub_401020();
}

void _start(int64_t arg1, int64_t arg2, void (* arg3)()) __noreturn
{
    int64_t stack_end_1;
    int64_t stack_end = stack_end_1;
    __libc_start_main(main, __return_addr, &ubp_av, __libc_csu_init, __libc_csu_fini, arg3, &stack_end);
    /* no return */
}

int64_t _dl_relocate_static_pie() __pure
{
    return;
}

void deregister_tm_clones()
{
    return;
}

void register_tm_clones()
{
    return;
}

void __do_global_dtors_aux()
{
    if (completed.0 != 0)
    {
        return;
    }
    deregister_tm_clones();
    completed.0 = 1;
}

void frame_dummy()
{
    /* tailcall */
    return register_tm_clones();
}

void usage(char* name) __noreturn
{
    if (is_checker == 0)
    {
        printf("Usage: [-hq] %s -i <infile> \n", name);
        puts("  -h          Print help informa…");
        puts("  -q          Don't submit resul…");
        puts("  -i <infile> Input file");
    }
    else
    {
        printf("Usage: [-h] %s -i <infile> -a <a…", name);
        puts("  -h           Print help inform…");
        puts("  -i <infile>  Input file");
        puts("  -a <authkey> Authentication ke…");
        puts("  -l <level>   Attack level");
    }
    exit(0);
    /* no return */
}

uint64_t initialize_target(int opt_level, int force_random)
{
    check_level = opt_level;
    uint32_t id = gencookie(target_id);
    cookie = id;
    authkey = gencookie(id);
    srandom((target_id + 1));
    int16_t rax_3 = scramble(random());
    int16_t rax_4;
    if (force_random != 0)
    {
        srandom(time(nullptr));
        rax_4 = random();
    }
    else
    {
        rax_4 = 0;
    }
    uint64_t rax_8 = (((rax_4 + rax_3) << 3) + 0x100);
    buf_offset = rax_8;
    target_prefix = 0x63;
    if ((notify != 0 && is_checker == 0))
    {
        void name;
        int32_t rax_10 = gethostname(&name, 0x100);
        int32_t rbp_1 = rax_10;
        if (rax_10 != 0)
        {
            puts("FAILED: Initialization error: Ru…");
            exit(8);
            /* no return */
        }
        int32_t rbx_1 = rax_10;
        while (true)
        {
            char* rdi_6 = *(&host_table + (rbx_1 << 3));
            if (rdi_6 == 0)
            {
                break;
            }
            if (strcasecmp(rdi_6, &name) == 0)
            {
                rbp_1 = 1;
                break;
            }
            rbx_1 = (rbx_1 + 1);
        }
        if (rbp_1 == 0)
        {
            printf("FAILED: Initialization error: Ru…", &name);
            exit(8);
            /* no return */
        }
        void status_msg;
        rax_8 = init_driver(&status_msg);
        if (rax_8 < 0)
        {
            printf("FAILED: Initialization error:\n%…", &status_msg);
            exit(8);
            /* no return */
        }
    }
    return rax_8;
}

int32_t main(int argc, char** argv)
{
    signal(0xb, seghandler);
    signal(7, bushandler);
    signal(4, illegalhandler);
    char const* const optstring;
    if (is_checker != 0)
    {
        signal(0xe, sigalrmhandler);
        alarm(5);
        optstring = "hi:a:l:";
    }
    else
    {
        optstring = "hqi:";
    }
    infile = stdin;
    int opt_level = 0;
    int32_t r14 = 0;
    int32_t rax_2;
    while (true)
    {
        char rax_4 = getopt(argc, argv, optstring);
        if (rax_4 == 0xff)
        {
            initialize_target(opt_level, 0);
            if ((is_checker != 0 && authkey != r14))
            {
                printf("Supplied authentication key 0x%x…", r14);
                check_fail();
                /* no return */
            }
            printf("Cookie: 0x%x\n", cookie);
            stable_launch(buf_offset);
            rax_2 = 0;
            break;
        }
        if ((rax_4 - 0x61) <= 0x10)
        {
            switch (rax_4)
            {
                case 0x61:
                {
                    r14 = strtoul(optarg, nullptr, 0x10);
                    continue;
                }
                case 0x68:
                {
                    usage(*argv);
                    /* no return */
                }
                case 0x69:
                {
                    FILE* rax_1 = fopen(optarg, "r");
                    infile = rax_1;
                    if (rax_1 == 0)
                    {
                        fprintf(stderr, "Cannot open input file '%s'\n", optarg);
                        rax_2 = 1;
                        break;
                    }
                    continue;
                }
                case 0x6c:
                {
                    opt_level = strtol(optarg, nullptr, 0xa);
                    continue;
                }
                case 0x71:
                {
                    notify = 0;
                    continue;
                }
            }
        }
        printf("Unknown flag '%c'\n", rax_4);
        usage(*argv);
        /* no return */
    }
    return rax_2;
}

uint64_t scramble(unsigned int val)
{
    int32_t var_30;
    for (int32_t i = 0; i <= 9; i = (i + 1))
    {
        &var_30[i] = ((i * 0xc3cd) + val);
    }
    var_30 = (var_30 * 0x5fb9);
    var_30 = (var_30 * 0x58e2);
    var_30 = (var_30 * 0x1f73);
    int32_t var_28;
    int32_t var_28_5 = (var_28 * -0x3dd24b545949514c);
    var_30 = (var_30 * 0xbd22);
    int32_t var_c;
    int32_t var_c_5 = (var_c * 0x6c0433b86c85cc98);
    int32_t var_14;
    int32_t var_14_10 = (var_14 * -0x6fcec9d145001000);
    int32_t var_1c;
    int32_t var_1c_11 = (var_1c * -0x5e1438842cd4cf00);
    int32_t var_10;
    int32_t var_10_7 = (var_10 * 0x462c8fd2bf163a68);
    int32_t var_20;
    int32_t var_20_7 = (var_20 * 0x2c8948d39ee95428);
    var_30 = (var_30 * 0x8746);
    var_30 = (var_30 * 0xd675);
    int32_t var_2c;
    int32_t var_2c_5 = (var_2c * 0x7ae8f8cc2f67e490);
    var_30 = (var_30 * 0xd3b7);
    int32_t var_18;
    int32_t var_18_9 = (var_18 * 0x27cd309e4d03bb00);
    int32_t var_24;
    int32_t var_24_7 = (var_24 * -0x2e51cd3b6c386e00);
    int32_t i_1 = 0;
    int32_t rdx_3 = 0;
    for (; i_1 <= 9; i_1 = (i_1 + 1))
    {
        rdx_3 = (rdx_3 + &var_30[i_1]);
    }
    return rdx_3;
}

unsigned int getbuf()
{
    void var_28;
    Gets(&var_28);
    return 1;
}

void touch1() __noreturn
{
    vlevel = 1;
    puts("Touch1!: You called touch1()");
    validate(1);
    exit(0);
    /* no return */
}

void touch2(unsigned int val) __noreturn
{
    uint64_t val_1 = val;
    vlevel = 2;
    if (cookie == val)
    {
        printf("Touch2!: You called touch2(0x%.8…", val_1);
        validate(2);
    }
    else
    {
        printf("Misfire: You called touch2(0x%.8…", val_1);
        fail(2);
    }
    exit(0);
    /* no return */
}

uint64_t hexmatch(unsigned int val, char* sval)
{
    void var_88;
    void* s = (&var_88 + (random() % 0x64));
    sprintf(s, "%.8x", val);
    int32_t rax_8;
    rax_8 = strncmp(sval, s, 9) == 0;
    return rax_8;
}

void touch3(char* sval) __noreturn
{
    vlevel = 3;
    if (hexmatch(cookie, sval) == 0)
    {
        printf("Misfire: You called touch3("%s")…", sval);
        fail(3);
    }
    else
    {
        printf("Touch3!: You called touch3("%s")…", sval);
        validate(3);
    }
    exit(0);
    /* no return */
}

int64_t test()
{
    getbuf();
    return printf("No exploit.  Getbuf returned 0x%…", 1);
}

uint64_t save_char(unsigned char c)
{
    uint64_t gets_cnt_1 = gets_cnt;
    if (gets_cnt_1 <= 0x3ff)
    {
        int32_t rcx_1;
        rcx_1 = (c >> 4);
        uint32_t rdx_1 = (gets_cnt_1 * 3);
        gets_buf[rdx_1] = *"0123456789ABCDEFProgram timed ou…"[(rcx_1 & 0xf)];
        gets_buf[(rdx_1 + 1)] = *"0123456789ABCDEFProgram timed ou…"[(c & 0xf)];
        gets_buf[(rdx_1 + 2)] = 0x20;
        gets_cnt_1 = (gets_cnt_1 + 1);
        gets_cnt = gets_cnt_1;
    }
    return gets_cnt_1;
}

int64_t save_term()
{
    int64_t rax_1 = (gets_cnt * 3);
    gets_buf[rax_1] = 0;
    return rax_1;
}

void check_fail() __noreturn
{
    printf("\nFAIL\t%ctarget\t%d\t%s\n", target_prefix, check_level, &gets_buf);
    exit(1);
    /* no return */
}

char* Gets(char* dest)
{
    gets_cnt = 0;
    char* dest_1 = dest;
    while (true)
    {
        int32_t rax_1 = getc(infile);
        if (rax_1 == 0xffffffff)
        {
            break;
        }
        if (rax_1 == 0xa)
        {
            break;
        }
        *dest_1 = rax_1;
        save_char(rax_1);
        dest_1 = &dest_1[1];
    }
    *dest_1 = 0;
    save_term();
    return dest;
}

void notify_server(int pass, int level)
{
    if (is_checker != 0)
    {
        return;
    }
    if (gets_cnt > 0x1f9c)
    {
        printf("Internal Error: Input string is …");
        exit(1);
        /* no return */
    }
    void* const str;
    if (pass == 0)
    {
        str = "FAIL";
    }
    else
    {
        str = "PASS";
    }
    char* var_2010 = &gets_buf;
    int64_t level_1 = level;
    void s;
    sprintf(&s, "%d:%s:0x%.8x:%ctarget:%d:%s", target_id, str);
    puts(str);
}

int64_t validate(int level)
{
    int64_t rax_1;
    if (is_checker != 0)
    {
        if (vlevel != level)
        {
            puts("\nMismatched validation levels");
            check_fail();
            /* no return */
        }
        uint32_t check_level_1 = check_level;
        if (check_level_1 != level)
        {
            printf("\nCheck level %d != attack level…", check_level_1, level);
            check_fail();
            /* no return */
        }
        rax_1 = printf("PASS\t%ctarget\t%d\t%s\n", target_prefix, level, &gets_buf);
    }
    else if (vlevel == level)
    {
        printf("Valid solution for level %d with…", level, target_prefix);
        rax_1 = notify_server(1, level);
    }
    else
    {
        puts("\nMismatched validation levels");
        rax_1 = notify_server(0, level);
    }
    return rax_1;
}

int64_t fail(int level)
{
    if (is_checker != 0)
    {
        check_fail();
        /* no return */
    }
    return notify_server(0, level);
}

void bushandler(int sig) __noreturn
{
    if (is_checker == 0)
    {
        puts("Crash!: You caused a bus error!");
        puts("Better luck next time");
        notify_server(0, 0);
        exit(1);
        /* no return */
    }
    puts("Bus error");
    check_fail();
    /* no return */
}

void seghandler(int sig) __noreturn
{
    if (is_checker == 0)
    {
        puts("Ouch!: You caused a segmentation…");
        puts("Better luck next time");
        notify_server(0, 0);
        exit(1);
        /* no return */
    }
    puts("Segmentation Fault");
    check_fail();
    /* no return */
}

void illegalhandler(int sig) __noreturn
{
    if (is_checker == 0)
    {
        puts("Oops!: You executed an illegal i…");
        puts("Better luck next time");
        notify_server(0, 0);
        exit(1);
        /* no return */
    }
    puts("Illegal instruction");
    check_fail();
    /* no return */
}

void sigalrmhandler(int sig) __noreturn
{
    if (is_checker == 0)
    {
        printf("\nTimeout!: Your attack takes mo…", 5);
        notify_server(0, 0);
        exit(1);
        /* no return */
    }
    puts("Timeout");
    check_fail();
    /* no return */
}

int64_t launch(long unsigned int offset)
{
    int64_t __saved_rbp;
    memset((((&__saved_rbp - ((offset + 0x17) & 0xfffffffffffffff0)) + 0xf) & 0xfffffffffffffff0), 0xf4, offset);
    if (infile == stdin)
    {
        printf("Type string:");
    }
    vlevel = 0;
    test();
    if (is_checker != 0)
    {
        puts("No exploit");
        check_fail();
        /* no return */
    }
    return puts("Normal return");
}

int64_t stable_launch(long unsigned int offset)
{
    int64_t rbx;
    int64_t var_8 = rbx;
    global_offset = offset;
    int64_t rax = mmap(0x55586000, 0x100000, 7, 0x132, 0, 0);
    if (rax != 0x55586000)
    {
        munmap(rax, 0x100000);
        fprintf(stderr, "Couldn't map stack to segment at…", 0x55586000);
        exit(1);
        /* no return */
    }
    stack_top = (rax + 0xffff8);
    global_save_stack = &var_8;
    launch(global_offset);
    uint64_t global_save_stack_1 = global_save_stack;
    int64_t rax_1 = munmap(rax, 0x100000);
    *global_save_stack_1;
    return rax_1;
}

char (*)[0x2000] rio_readinitb(struct { int rio_fd; int rio_cnt; char* rio_bufptr; char rio_buf[0x2000]; }* rp, int fd)
{
    rp->rio_fd = fd;
    rp->rio_cnt = 0;
    rp->rio_bufptr = &rp->rio_buf;
    return &rp->rio_buf;
}

void sigalrm_handler(int sig) __noreturn
{
    fprintf(stderr, "Program timed out after %d secon…", 0);
    exit(1);
    /* no return */
}

int urlencode(unsigned char* src, unsigned char* dst)
{
    unsigned char* src_1 = src;
    unsigned char* dst_1 = dst;
    int32_t rax = strlen(src);
    while (true)
    {
        int32_t r12_1 = (rax - 1);
        if (rax == 0)
        {
            break;
        }
        unsigned char rdx_1 = *src_1;
        rax = rdx_1 == 0x2d;
        if ((rdx_1 == 0x2a | rax) != 0)
        {
        label_40221a:
            *dst_1 = rdx_1;
            dst_1 = &dst_1[1];
        }
        else
        {
            if (rdx_1 == 0x2e)
            {
                goto label_40221a;
            }
            if (rdx_1 == 0x5f)
            {
                goto label_40221a;
            }
            if ((rdx_1 - 0x30) <= 9)
            {
                goto label_40221a;
            }
            if ((rdx_1 - 0x41) <= 0x19)
            {
                goto label_40221a;
            }
            if ((rdx_1 - 0x61) <= 0x19)
            {
                goto label_40221a;
            }
            if (rdx_1 == 0x20)
            {
                *dst_1 = 0x2b;
                dst_1 = &dst_1[1];
            }
            else
            {
                bool rcx_1 = ((rdx_1 - 0x20) <= 0x5f | rdx_1 == 9);
                if (rcx_1 == 0)
                {
                    rax = -1;
                    break;
                }
                unsigned char s;
                sprintf(&s, "%%%02X", rdx_1, rcx_1);
                *dst_1 = s;
                char var_1f;
                dst_1[1] = var_1f;
                char var_1e;
                dst_1[2] = var_1e;
                dst_1 = &dst_1[3];
            }
        }
        src_1 = &src_1[1];
        rax = r12_1;
    }
    return rax;
}

long unsigned int rio_writen(int fd, void* usrbuf, long unsigned int n)
{
    void* buf = usrbuf;
    long unsigned int nbytes = n;
    long unsigned int n_1;
    while (true)
    {
        if (nbytes == 0)
        {
            n_1 = n;
            break;
        }
        ssize_t rax_1 = write(fd, buf, nbytes);
        if (rax_1 <= 0)
        {
            if (*__errno_location() != 4)
            {
                n_1 = -1;
                break;
            }
            rax_1 = 0;
        }
        nbytes = (nbytes - rax_1);
        buf = (buf + rax_1);
    }
    return n_1;
}

uint64_t rio_read(struct { int rio_fd; int rio_cnt; char* rio_bufptr; char rio_buf[0x2000]; }* rp, char* usrbuf, long unsigned int n)
{
    uint64_t rio_cnt_2;
    while (true)
    {
        int rio_cnt = rp->rio_cnt;
        if (rio_cnt > 0)
        {
            if (rio_cnt >= n)
            {
                rio_cnt = n;
            }
            uint64_t rio_cnt_1 = rio_cnt;
            memcpy(usrbuf, rp->rio_bufptr, rio_cnt_1);
            rp->rio_bufptr = &rp->rio_bufptr[rio_cnt_1];
            rp->rio_cnt = (rp->rio_cnt - rio_cnt);
            rio_cnt_2 = rio_cnt_1;
            break;
        }
        int rax_2 = read(rp->rio_fd, &rp->rio_buf, 0x2000);
        rp->rio_cnt = rax_2;
        if (rax_2 < 0)
        {
            if (*__errno_location() != 4)
            {
                rio_cnt_2 = -1;
                break;
            }
        }
        else
        {
            if (rax_2 == 0)
            {
                rio_cnt_2 = 0;
                break;
            }
            rp->rio_bufptr = &rp->rio_buf;
        }
    }
    return rio_cnt_2;
}

long int rio_readlineb(struct { int rio_fd; int rio_cnt; char* rio_bufptr; char rio_buf[0x2000]; }* rp, void* usrbuf, long unsigned int maxlen)
{
    void* usrbuf_3 = usrbuf;
    int64_t rbx = 1;
    int64_t rax_1;
    while (true)
    {
        if (rbx < maxlen)
        {
            char usrbuf_1;
            int32_t rax_2 = rio_read(rp, &usrbuf_1, 1);
            if (rax_2 == 1)
            {
                char usrbuf_2 = usrbuf_1;
                *usrbuf_3 = usrbuf_2;
                if (usrbuf_2 != 0xa)
                {
                    rbx = (rbx + 1);
                    usrbuf_3 = (usrbuf_3 + 1);
                    continue;
                }
                else
                {
                    usrbuf_3 = (usrbuf_3 + 1);
                }
            }
            else
            {
                if (rax_2 != 0)
                {
                    rax_1 = -1;
                    break;
                }
                if (rbx == 1)
                {
                    rax_1 = 0;
                    break;
                }
            }
        }
        *usrbuf_3 = 0;
        rax_1 = rbx;
        break;
    }
    return rax_1;
}

int32_t submitr(char* hostname, int port, char* course, char* userid, char* lab, char* result, char* status_msg)
{
    int32_t var_805c = 0;
    int32_t fd = socket(2, 1, 0);
    int32_t rax_16;
    if (fd < 0)
    {
        __builtin_strcpy(status_msg, "Error: Client unable to create socket");
        rax_16 = -1;
    }
    else
    {
        struct hostent* rax = gethostbyname(hostname);
        if (rax == 0)
        {
            __builtin_strncpy(status_msg, "Error: DNS is unable to resolve server address", 0x2f);
            close(fd);
            rax_16 = -1;
        }
        else
        {
            int64_t addr = 0;
            int64_t var_40_1 = 0;
            addr = 2;
            memmove(&*addr[4], *rax->h_addr_list, rax->h_length);
            *addr[2] = (ROLW(port, 8));
            if (connect(fd, &addr, 0x10) < 0)
            {
                __builtin_strncpy(status_msg, "Error: Unable to connect to the server", 0x27);
                close(fd);
                rax_16 = -1;
            }
            else
            {
                uint64_t rax_2 = strlen(result);
                int var_a078;
                var_a078 = strlen(course);
                var_a078 = (strlen(userid) + var_a078);
                if ((((strlen(lab) + var_a078) + (rax_2 * 3)) + 0x80) > 0x2000)
                {
                    __builtin_strcpy(status_msg, "Error: Result string too large. Increase SUBMITR_MAXBUF");
                    close(fd);
                    rax_16 = -1;
                }
                else
                {
                    void s;
                    __builtin_memset(&s, 0, 0x2000);
                    if (urlencode(result, &s) < 0)
                    {
                        __builtin_strncpy(status_msg, "Error: Result string contains an illegal or unprintable character.", 0x43);
                        close(fd);
                        rax_16 = -1;
                    }
                    else
                    {
                        void var_4058;
                        sprintf(&var_4058, "GET /submit?user=%s&course=%s&re…", userid, course, &s, hostname);
                        if (rio_writen(fd, &var_4058, strlen(&var_4058)) < 0)
                        {
                            __builtin_strncpy(status_msg, "Error: Client unable to write to the result server", 0x33);
                            close(fd);
                            rax_16 = -1;
                        }
                        else
                        {
                            void rp;
                            rio_readinitb(&rp, fd);
                            int64_t rax_13 = rio_readlineb(&rp, &var_4058, 0x2000);
                            bool c_1 = false;
                            bool z_1 = (rax_13 & rax_13) == 0;
                            if ((z_1 || (rax_13 & rax_13) < 0 != false))
                            {
                                __builtin_strncpy(status_msg, "Error: Client unable to read first header from result server", 0x3d);
                                close(fd);
                                rax_16 = -1;
                            }
                            else
                            {
                                void var_a068;
                                void var_8058;
                                __isoc99_sscanf(&var_4058, "%s %d %[a-zA-z ]", &var_8058, &var_805c, &var_a068);
                                while (true)
                                {
                                    void* rsi_7 = &var_4058;
                                    int64_t i = 3;
                                    void* const rdi_14 = "\r\n";
                                    while (i != 0)
                                    {
                                        char temp0_1 = *rsi_7;
                                        char temp1_1 = *rdi_14;
                                        c_1 = temp0_1 < temp1_1;
                                        z_1 = temp0_1 == temp1_1;
                                        rsi_7 = (rsi_7 + 1);
                                        rdi_14 = (rdi_14 + 1);
                                        i = (i - 1);
                                        if (!(z_1))
                                        {
                                            break;
                                        }
                                    }
                                    int64_t rax_15;
                                    rax_15 = (!(z_1) && !(c_1));
                                    rax_15 = (rax_15 - 0);
                                    if (rax_15 == 0)
                                    {
                                        if (rio_readlineb(&rp, &var_4058, 0x2000) <= 0)
                                        {
                                            __builtin_strncpy(status_msg, "Error: Client unable to read status message from result server", 0x3f);
                                            close(fd);
                                            rax_16 = -1;
                                        }
                                        else
                                        {
                                            int32_t rdx_5 = var_805c;
                                            bool c_2 = rdx_5 < 0xc8;
                                            bool z_2 = rdx_5 == 0xc8;
                                            if (!(z_2))
                                            {
                                                sprintf(status_msg, "Error: HTTP request failed with …", rdx_5, &var_a068);
                                                close(fd);
                                                rax_16 = -1;
                                            }
                                            else
                                            {
                                                strcpy(status_msg, &var_4058);
                                                close(fd);
                                                int64_t i_1 = 4;
                                                void* const rdi_26 = &data_4036ed;
                                                char* status_msg_1 = status_msg;
                                                while (i_1 != 0)
                                                {
                                                    char temp2_1 = *status_msg_1;
                                                    char temp3_1 = *rdi_26;
                                                    c_2 = temp2_1 < temp3_1;
                                                    z_2 = temp2_1 == temp3_1;
                                                    status_msg_1 = &status_msg_1[1];
                                                    rdi_26 = (rdi_26 + 1);
                                                    i_1 = (i_1 - 1);
                                                    if (!(z_2))
                                                    {
                                                        break;
                                                    }
                                                }
                                                rax_16 = ((!(z_2) && !(c_2)) - 0);
                                                bool c_3 = false;
                                                bool z_3 = (rax_16 & rax_16) == 0;
                                                if (!(z_3))
                                                {
                                                    int64_t i_2 = 5;
                                                    void* const rdi_27 = "OK\r\n";
                                                    char* status_msg_2 = status_msg;
                                                    while (i_2 != 0)
                                                    {
                                                        char temp4_1 = *status_msg_2;
                                                        char temp5_1 = *rdi_27;
                                                        c_3 = temp4_1 < temp5_1;
                                                        z_3 = temp4_1 == temp5_1;
                                                        status_msg_2 = &status_msg_2[1];
                                                        rdi_27 = (rdi_27 + 1);
                                                        i_2 = (i_2 - 1);
                                                        if (!(z_3))
                                                        {
                                                            break;
                                                        }
                                                    }
                                                    rax_16 = (!(z_3) && !(c_3));
                                                    rax_16 = (rax_16 - 0);
                                                    rax_16 = rax_16;
                                                    bool c_4 = false;
                                                    bool z_4 = (rax_16 & rax_16) == 0;
                                                    if (!(z_4))
                                                    {
                                                        int64_t i_3 = 3;
                                                        void* const rdi_28 = &data_4036f6;
                                                        char* status_msg_3 = status_msg;
                                                        while (i_3 != 0)
                                                        {
                                                            char temp6_1 = *status_msg_3;
                                                            char temp7_1 = *rdi_28;
                                                            c_4 = temp6_1 < temp7_1;
                                                            z_4 = temp6_1 == temp7_1;
                                                            status_msg_3 = &status_msg_3[1];
                                                            rdi_28 = (rdi_28 + 1);
                                                            i_3 = (i_3 - 1);
                                                            if (!(z_4))
                                                            {
                                                                break;
                                                            }
                                                        }
                                                        rax_16 = (!(z_4) && !(c_4));
                                                        rax_16 = (rax_16 - 0);
                                                        rax_16 = rax_16;
                                                        if (rax_16 != 0)
                                                        {
                                                            rax_16 = -1;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        break;
                                    }
                                    rax_15 = rio_readlineb(&rp, &var_4058, 0x2000);
                                    c_1 = false;
                                    z_1 = (rax_15 & rax_15) == 0;
                                    if (!((!(z_1) && (rax_15 & rax_15) < 0 == false)))
                                    {
                                        __builtin_strcpy(status_msg, "Error: Client unable to read headers from the result server");
                                        close(fd);
                                        rax_16 = -1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return rax_16;
}

void init_timeout(int timeout)
{
    if (timeout == 0)
    {
        return;
    }
    int timeout_1 = timeout;
    if (timeout < 0)
    {
        timeout_1 = 0;
    }
    signal(0xe, sigalrm_handler);
    alarm(timeout_1);
}

int init_driver(char* status_msg)
{
    signal(0xd, 1);
    signal(0x1d, 1);
    signal(0x1d, 1);
    int32_t fd = socket(2, 1, 0);
    int64_t rax_2;
    if (fd < 0)
    {
        __builtin_strcpy(status_msg, "Error: Client unable to create socket");
        rax_2 = 0xffffffff;
    }
    else
    {
        struct hostent* rax = gethostbyname(&hostname);
        if (rax == 0)
        {
            __builtin_strncpy(status_msg, "Error: DNS is unable to resolve server address", 0x2f);
            close(fd);
            rax_2 = 0xffffffff;
        }
        else
        {
            int64_t addr = 0;
            int64_t var_20_1 = 0;
            addr = 2;
            memmove(&*addr[4], *rax->h_addr_list, rax->h_length);
            *addr[2] = 0x9a3c;
            if (connect(fd, &addr, 0x10) < 0)
            {
                __builtin_strcpy(status_msg, "changeme.yourschool.edu");
                __builtin_strncpy(status_msg, "Error: Unable to connect to server", 0x23);
                close(fd);
                rax_2 = 0xffffffff;
            }
            else
            {
                close(fd);
                *status_msg = 0x4b4f;
                status_msg[2] = 0;
                rax_2 = 0;
            }
        }
    }
    return rax_2;
}

uint64_t driver_post(char* userid, char* course, char* lab, char* result, int autograded, char* status_msg)
{
    uint64_t autograded_1;
    if (autograded != 0)
    {
        printf("\nAUTORESULT_STRING=%s\n", result);
        *status_msg = 0x4b4f;
        status_msg[2] = 0;
        autograded_1 = 0;
    }
    else
    {
        if ((userid == 0 || (userid != 0 && *userid == 0)))
        {
            *status_msg = 0x4b4f;
            status_msg[2] = 0;
            autograded_1 = autograded;
        }
        if ((userid != 0 && *userid != 0))
        {
            autograded_1 = submitr(&hostname, 0x3c9a, course, userid, lab, result, status_msg);
        }
    }
    return autograded_1;
}

int check(unsigned int c) __pure
{
    if ((c >> 0x1c) == 0)
    {
        return 0;
    }
    int32_t rcx = 0;
    while (true)
    {
        if (rcx > 0x1f)
        {
            return 1;
        }
        if ((c >> rcx) == 0xa)
        {
            break;
        }
        rcx = (rcx + 8);
    }
    return 0;
}

uint64_t gencookie(int id)
{
    srandom((id + 1));
    unsigned int c;
    int32_t i;
    do
    {
        c = random();
        i = check(c);
    } while (i == 0);
    return c;
}

void __libc_csu_init()
{
    _init();
    int64_t i = 0;
    do
    {
        int64_t rdx;
        int64_t rsi;
        int32_t rdi;
        &__frame_dummy_init_array_entry[i](rdi, rsi, rdx);
        i = (i + 1);
    } while (1 != i);
}

void __libc_csu_fini() __pure
{
    return;
}

int64_t _fini() __pure
{
    return;
}

